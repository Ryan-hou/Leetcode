"平衡"的BST--红黑树(保持了BST的有序性45555x)

红黑树与2-3树的等价性：
“左倾”是一个特殊的条件，添加上“左倾”这个条件后，
红黑树才真正和2-3树等价（否则其实红黑树是和2-4树等价)
红黑树的添加和删除操作性能会好于AVL，查询性能会差于AVL(虽然二者复杂度都是O(logn),
红黑树的最大高度为 2logn)

2-3树：
* 满足二分搜索树的基本性质(但不是二叉树)
* 节点可以存放一个元素或者两个元素(节点存在2个孩子或者3个孩子,2-3树的由来)
* 2节点／3节点
* 2-3树是一棵绝对平衡的树（任意一个节点，左右子树的高度相等）

* 红黑树中红色节点和其父亲节点一起表示2-3树中的3节点
* 所有的红色节点都是左倾的（左倾红黑树）
* 初始节点为红色，表示该节点需要与代表2-3树中的3节点的另一个黑色节点融合
* 空节点为黑节点(空节点也是一个空的红黑树，根节点为黑色节点)／根节点是黑节点
* 如果一个节点是红色的，那么他的孩子节点都是黑色的
* 从任意一个节点到所有叶子节点，经过的黑色节点是一样的(类比2-3树中无论是2节点还是3节点，对应红黑树都有一个黑色节点)
* 红黑树是保持"黑平衡"的二叉树（根节点到任意叶子节点，走过的黑色节点数目都一样），严格意义上，不是"平衡的"
* 红黑树中添加节点，等同于在2-3树中的3节点融合元素(3种情况4)

完全随机的数据，BST就很好用（不会退化成链表）
查询较多的情况，AVL树很好用
红黑树牺牲了平衡性(2logn的高度)，统计性能更优（综合增删查改所有的操作），添加删除操作比AVL快一些

算法导论：
红黑树的性质：
* 所有节点非红即黑；
* 根节点为黑；
* 最后的NULL节点为黑；
* 红节点的孩子一定为黑（红色性质）；
* 黑平衡（黑色性质）

我们在这一章实现的左倾红黑树一定是红黑树；但是红黑树不一定全是左倾红黑树。换句话说，我们的代码为了维护“左倾”这个性质，
做了额外的事情，消耗了性能，使得我们在这个课程中的实现，没有“任何不平衡都可以在三次旋转内解决”这么好的性能优势。
