哈希表：
拆分成两部分来理解：哈希和表
1）表：说明哈希表是一个存储容器，通常是一个数组
2）哈希：需要借助哈希函数，把相关的键转为索引，用来实现存储

哈希表充分体现了算法设计领域的经典思想：空间换时间(在发生大量哈希冲突后会提高时间复杂度)（类似的还有：缓存／缓冲／ThreadLocal等）
相应的还有时间换空间：各种虚拟存储技术都是时间换空间的技术啊，什么请求分页、请求分段、请求段页式，都是，
这些都是让访问时间增加了，但是扩充了主存的逻辑容量，使得大于主存容量的程序也可以得到执行
哈希表是时间和空间的权衡
哈希函数的设计很重要（"键"通过哈希函数得到的"索引"分布越均匀越好，可以有效的利用空间，减少哈希冲突）

* 哈希函数 -- 把"键"转为"索引"

借助哈希函数，可以给数组索引赋予"键"所代表的语义
最简单的比如把小写英文字母转为索引：f(ch) = ch - 'a'

* 很难保证每一个"键"通过哈希函数的转换对应不同的"索引" -- 哈希冲突

哈希函数的设计

转成整数处理
* 对于大整数，最简单的是模一个素数(数学可证)（HashMap里不是模素数，文档里有相应解释）
* 对于浮点数，在计算机中都是32位或者64位二进制表示，只不过计算机解析成了浮点数
* 字符串: 转成整形处理
Java String:
f(n)=char[0]+char[1]*31+char[2]*31^2+...+char[n]*31^(n-1)
for i in [0,length): h = 31 * h + val[i];
* 复合类型：转为整形

原则：
* 一致性：如果 a==b(a.equals(b)), hash(a)==hash(b)
* 高效性：计算高效简便(哈希表的设计就是为了实现高效存取，通过底层数组空间换时间，如果哈希计算太耗时就得不偿失了)
* 均匀性:哈希值分布均匀(避免哈希冲突)

解决hash冲突：
* 链地址法(separate chaining)：封闭地址，排他性
发生冲突的键构成查找表--链表或者平衡树(Red-black tree)，比如HashMap
* 开放地址法--可以使用（linear-probe，平方探测法，二次哈希法等来计算步长）
比如ThreadLocal

* 均摊时间复杂度O(1)，哈希表相比平衡树牺牲了顺序性

