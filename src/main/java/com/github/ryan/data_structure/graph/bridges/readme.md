桥和割点

重点掌握在算法实现过程中:
* 一定要明确变量的语义
* 一定要维护好变量的语义
**semantics -> maintain semantics**
再强调多少次都不为过！！！很多时候算法出现bug或者代码逻辑混乱，根本上就是变量的语义
定义的不够清楚，后面的代码也没能维护住变量的语义

对于 DFS 遍历树和 BFS 遍历树的比较：
* BFS 可以解决无权图的最短路径
* DFS 遍历中，非遍历树的边指向自己的祖先节点 -> 桥和割点的求解用到这个性质，因此只能使用 DFS
* DFS 使用递归，代码更加简洁，明确递归的语义后，写出的代码更不容易出现bug
* 对于图论包括其他数据结构，遍历都是一个很重要的操作，我们可以通过在遍历时记录不同的信息来
    解决不同的问题
    
桥:
* 是什么 -> 对于无向图，删除某一条边后，整个图的连通分量发生变化，那么这条边就是桥
    -> 桥意味着图中最脆弱的关系
* 应用 -> 交通系统的关键通路 / 社交网络的关键关系
* 一个图中可以有多个桥，树中的每一个边都是桥
* DFS -> 有难度，需要记录的信息更加多元
* 和判断一张图是否有环不同，环是整张图的属性，而桥是一条边的属性，寻找桥的算法需要遍历每一条边
* 遍历每条边(v-w)，看是否存在通过 w 的另一条边可以到达 v 或者 v 的祖先 -> 存在则 v-w 不是桥
* 需要记录每个顶点的访问顺序 ord[v] 和通过顶点 v 从另一条路能到达的最小 ord 值 -> low[v]

割点:
* 是什么 -> 对于无向图，如果删除了一个顶点(顶点邻边也删除)，整个图的连通分量数量发生变化，
    则这个顶点是割点 (cut point / articulation point) 
* 割点是图中最脆弱的点 -> 桥也叫割边
* 求解思路和桥类似，区别在于:
    1) 如果点 v 有一个孩子 w, 满足 low[w] >= ord[v] 则 v 是割点，相比于桥的求解，这里等于也成立，
    因为等于时，该点删除后，相邻的所有边也删除了，w 回不到 v 的，也回不到 v 父亲
    2) 存在一个 corner case: 根节点 -> 对于根节点，如果遍历树中根节点有一个以上的孩子，则根节点是割点