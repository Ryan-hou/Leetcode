优先队列(也是队列Queue)

* 普通队列：先进先出
* 优先队列：出队顺序和入队顺序无关，和优先级相关
 
使用：
操作系统动态选择优先级最高的任务执行(动态！如果是静态的，使用一下排序算法即可)
游戏ai(选择哪个敌人进行攻击)
用户需要自己定义优先级的高低(优先级何为高？何为低？)

在N个元素中选取前M个元素:构造M的元素的堆 O(nlogm)，比排序 O(nlogn) 要快：
我们创建了一个最多包含M个元素的堆。在这个堆上的基本操作是O(logM)的。
对于每一个元素，我们都可能要在这个堆上进行一次操作，所以时间复杂度是O(NlogM)的。
如果你一上来对数组中的所有元素组织成一个堆，这个过程是O(N)的（使用heapify），之后在这个巨大的堆中取前M个元素，
时间复杂度是O(MlogN)的，综合这个过程，时间复杂度是：O(N + MlogN)的。
后一种方法有一个缺点，或者说是限制，就是需要在算法计算初始，就已知所有的数据。
但是在实际中，数据很有可能是一点一点流进来的，而不是一次性给出的（比如用户的下单数据）；
同时，由于N巨大，很有可能维持一个包含N个元素的堆是不现实的，而维持一个包含M个元素的堆，是很简单的。
比如要实时统计单笔订单金额最高的前100个订单，前一种方法只需要维护一个包含100个元素的堆，
而后一种方法需要维护一个包含订单总量那么多元素的堆，而订单总量可能是一个天文数字

使用快排思路：
在 N 个元素中选出前 M 个元素这个问题, 使用优先队列时间复杂度是O(NlogM), 但这样得到的 M 个元素是排好序的, 
如果对这 M 个元素不要求排序, 用快速排序的思路找到第 M 大的元素, 然后它和它后面的元素就已经满足要求了, 时间复杂度O(N).
总结：
 1. 获取原始数据的难度越大, 限制越多, 相应解决问题思路就越少, 可能只能选复杂度高一些的算法. 
 2. 对于得到的结果, 如果额外解决了一些其他的问题, 那么时间复杂度可能也不是最优的. 



实现（优先队列也是抽象数据类型，底层可以采用不同的结构实现，对用户来说是透明的）：
1）普通线性结构：入队O(1) 出队O(n)（O(n)时间复杂度的操作，处理n个元素，时间复杂度就变为O(n^2)）
2）顺序线性结构：入队O(n) 出队O(1)
3）堆：入队O(logn) 出队O(logn) (最差复杂度O(logn))


堆--二叉堆(binary heap)：
* 二叉堆是完全二叉树
* 满二叉树：除了叶子节点，其他节点左右孩子都不为空；完全二叉树：把元素顺序一层一层排列成树的形状(右下部分可能缺失)
* 最大堆：堆中所有节点的值都大于等于其孩子节点的值；根节点是树中最大的值(java PriorityQueue使用最小堆，同时可以传入比较器自定义优先级比较，很好的设计)
* 使用数组表示完全二叉树：通过计算数组下标来找到左右孩子／及其父亲(数学归纳法可证)