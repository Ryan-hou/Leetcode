package com.github.ryan.personal.algorithm.bit;

import lombok.extern.slf4j.Slf4j;

/**
 * @author ryan.houyl@gmail.com
 * @description:
 * @className: AddUseBit
 * @date January 24,2018
 */

/**
 * 位运算实现加法分析：
 * 首先我们可以分析人们是如何做十进制的加法的，比如是如何得出5+17=22这个结果的。实际上，我们可以分成三步的：
 * 第一步只做各位相加不进位，此时相加的结果是12（个位数5和7相加不要进位是2，十位数0和1相加结果是1）；
 * 第二步做进位，5+7中有进位，进位的值是10；
 * 第三步把前面两个结果加起来，12+10的结果是22，刚好5+17=22。
 *
 * 接下来我们试着把二进制上的加法用位运算来替代。
 * 第一步不考虑进位，对每一位相加。0加0与1加1的结果都0，0加1与1加0的结果都是1。
 * 我们可以注意到，这和异或的结果是一样的。对异或而言，0和0、1和1异或的结果是0，而0和1、1和0的异或结果是1。
 * 接着考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。
 * 此时我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0。
 * 第三步把前两个步骤的结果相加。如果我们定义一个函数add，第三步就相当于输入前两步骤的结果来递归调用自己。
 *
 * 补充一下，最后应加入一个递归有限步结束的证明。
 * 简单证明如下：
 * 因为每步的和都可分解为两个部分，一个异或值（记为A)，一个与值（记为B)。
 * 第n+1步与第n步相比：
 * B的二进制表示中1的个数是不增的（由与的性质可知）。countTrueBits(B(n+1)) <= countTrueBits(B(n))
 * 另外，B(n)一直在左移，并且 B的bit数有限，故二进制1的个数不可能一直保持不变，因此只能越来越少。最后终止在有限步
 *
 */

@Slf4j
public class AddUseBit {

    public static int add(int num1, int num2) {
        // 递归出口
        if (num2 == 0) {
            return num1;
        }

        int sum = num1 ^ num2; // 求二进制每一位的和，舍弃进位
        int carry = (num1 & num2) << 1; // 由与操作的性质可知num1&num2中0的个数保持不增，不断左移直到为0
        return add(sum, carry);
    }


    public static void main(String[] args) {
        log.info("result = {}", add(100, 208));
    }
}
